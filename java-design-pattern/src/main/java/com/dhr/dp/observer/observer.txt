java 的观察者模式（发布-订阅模式）解析


观察者模式典型实现方式：
  1、定义2个接口：观察者（通知）接口、被观察者（主题）接口
  2、定义2个类，观察者对象实现观察者接口、主题类实现被观者接口
  3、主题类注册自己需要通知的观察者
  4、主题类某个业务逻辑发生时通知观察者对象，每个观察者执行自己的业务逻辑。

关键点(摘抄)：

　　　　1、针对观察者与被观察者分别定义接口，有利于分别进行扩展。

　　　　2、重点就在被观察者的实现中：

　　　　　　（1）定义观察者集合，并定义针对集合的添加、删除操作，用于增加、删除订阅者（观察者）

　　　　　　（2）定义通知方法，用于将新情况通知给观察者用户（订阅者用户）

　　　　3、观察者中需要有个接收被观察者通知的方法。

　　如此而已！

　　观察者模式定义的是一对多的依赖关系，一个被观察者可以拥有多个观察者，并且通过接口对观察者与被观察者进行逻辑解耦，降低二者的直接耦合。

　　如此这般，想了一番之后，突然发现这种模式与桥接模式有点类似的感觉。

　　桥接模式也是拥有双方，同样是使用接口（抽象类）的方式进行解耦，使双方能够无限扩展而互不影响，其实二者还是有者明显的区别：

　　　　1、主要就是使用场景不同，桥接模式主要用于实现抽象与实现的解耦，主要目的也正是如此，为了双方的自由扩展而进行解耦，这是一种多对多的场景。观察者模式侧重于另一方面的解耦，侧重于监听方面，侧重于一对多的情况，侧重于一方发生情况，多方能获得这个情况的场景。

　　　　2、另一方面就是编码方面的不同，在观察者模式中存在许多独有的内容，如观察者集合的操作，通知的发送与接收，而在桥接模式中只是简单的接口引用。

##接下来，以微博大V和粉丝间微博发布动态推送为例##

记录总结
1.观察者模式优点：
（1）抽象主题只依赖于抽象观察者
（2）观察者模式支持广播通信
（3）观察者模式使信息产生层和响应层分离
2.观察者模式缺点：
（1）如一个主题被大量观察者注册，则通知所有观察者会花费较高代价（可采用异步通知处理方式）
（2）如果某些观察者的响应方法被阻塞，整个通知过程即被阻塞，其它观察者不能及时被通知（异步通知并响应，阻塞超时丢弃或加入重试队列）